# Store Package
This package contains the implementation of a good part of the kernel, in particular it contains the implementation of the database buffer pool. <br> <br>
![tesi](https://github.com/user-attachments/assets/c5e46d3c-c74a-46ed-9ed2-8bc2b643c2c8)
The buffer pool consists of the following modules: 
* Address Binder
* Cache Page
* Buffer Pool
* Hash Function
* Storage API
* Concurrency Control
* Pagination Algorithm
* Recovery Algorithm
### Address Binder
This module is responsible for translating hash functions into indexes, so you can map the entries in the array of pages contained in the buffer pool <br>
```Go
func (a *AddressBinder) TranslateHash(hash uint32) uint32 {
	a.bucketAddress = hash % BUFFER_POOL_SIZE
	return a.bucketAddress
}
```
This piece of code translates the value generated by the hash function into an index for an array.
### Cache Page
This module contains the implementation of pages. A page indicates only one bucket of a hash map, however due to the possibility of collisions a linked list is implemented to manage the collisions. Hence each bucket is placed in the managed linked list of the page itself. <br>
Buckets are composed of an array of bytes with a maximum size of 2KB. Buckets can store only a pair of K-V, the key is separated from the value through the character @, this will make the research phase easier. <br><br>
![page](https://github.com/user-attachments/assets/ac6a0b10-2220-4329-9cd5-9798b62ba117)
Note that each bucket contains not only the data part but also the logical clock which will use the page replacement algorithm
```Go
type Bucket struct {
	bucketData    [PAGE_SIZE]byte
	knucklesClock int
}
```
### Buffer Pool
The buffer pool is implemented as an array of 3000 elements, with each element in the array representing a page and, more specifically, a single bucket. However, due to possible collisions, each page may contain a list of buckets, which degrades overall performance. <br> <br>
It is possible to manipulate the buffer pool by adding and removing buckets through the methods provided by the BufferPool class. These methods must be invoked by the KnucklesMap class.
Those are: 
* WritePage
* ReadPage
* EvictPage, which only the paginator can call.
### Hash Function 
The hash function used in KnucklesDB is the 128-bit Spooky Hash; however, the produced value is converted into a 32-bit integer. <br> <br>
To call the hash function, you can use the Hash32 method contained in the SpookyHash class.
### Storage API
The KnucklesMap class contains the Write and Read methods, which the server must call to handle client requests. These methods, in turn, will call the methods contained in the SpookyHash, BufferPool, and AddressBinder classes. <br> <br>
* Set() -> WritePage() -> AddPage().
* Get() -> ReadPage() -> ReadValueFromBucket().
### Concurrency Control
KnucklesDB implements a concurrent hash table as a primary in-memory storage mechanism.

### Pagination Algorithm
The pagination algorithm is based on the clock algorithm with a second chance. Each entry is stored in an auxiliary hash map, and every 3 seconds a round of the algorithm is scheduled. In the first round, it sets the flags of each entry to false, and after another 3 seconds, it checks how many entries are still set to false â€” these will be removed from the algorithm. <br>
The algorithm is implemented in the file called detector_buffer.go 

### Recovery Algorithm
The recovery algorithm is implemented also in the store package, this way is possibile to log in the WAL all the occuring entries, and to reconstruct the memory content after a crash by reading the WAL.
Writing to the WAL does not require a global lock, thanks to the implementation of the single-writer (or singular update) pattern.
